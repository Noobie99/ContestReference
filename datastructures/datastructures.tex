\section{Datenstrukturen}

\subsection{Union-Find}
\lstinputlisting{datastructures/unionFind.cpp}

\subsection{Segmentbaum}
\lstinputlisting{datastructures/segmentTree.cpp}

\subsection{2D-Segmentbaum}
\lstinputlisting{datastructures/segmentTree2D.cpp}

\subsection{Fenwick Tree}
\lstinputlisting{datastructures/fenwickTree.cpp}
\lstinputlisting{datastructures/fenwickTreeNiklas.cpp}

\subsection{Sparse Table}
\lstinputlisting{datastructures/sparseTable.cpp}

\subsection{STL-Tree}
\lstinputlisting{datastructures/stlTree.cpp}

\subsection{STL-Rope (Implicit Cartesian Tree)}
\lstinputlisting{datastructures/stlRope.cpp}

\subsection{Treap (Cartesian Tree)}
\lstinputlisting{datastructures/treap.cpp}

\subsection{STL Priority Queue}
Nicht notwendig, wenn Smaller-Larger-Optimization greift.
\lstinputlisting{datastructures/stlPQ.cpp}

\subsection{Lower/Upper Envelop (Convex Hull Optimization)}
Um aus einem lower envelope einen upper envelope zu machen (oder umgekehrt), einfach beim Einf√ºgen der Geraden $m$ und $b$ negieren.
\lstinputlisting{datastructures/monotonicConvexHull.cpp}
\lstinputlisting{datastructures/dynamicConvexHull.cpp}
